---
title: "Single-cell PBMC Example"
author: "karltayeb"
date: "2022-03-16"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Introduction

Our goals here are to run Logistic SuSiE on differential expression results from TCGA.
We want to assess:

1. If the resulting enrichment results look good/interpretable across multiple/concatenated gene sets
2. Assess sensitivity to a range of p-value thresholds
3. Evaluate the potential of the summary stat latent model

```{r message=FALSE, results='hide'}
library(GSEABenchmarkeR)
library(EnrichmentBrowser)
library(tidyverse)
library(susieR)
library(DT)
library(kableExtra)

source('code/load_gene_sets.R')
source('code/utils.R')
source('code/logistic_susie_vb.R')
source('code/logistic_susie_veb_boost.R')
source('code/latent_logistic_susie.R')
```

## Setup

### Load Gene Sets
`loadGeneSetX` uniformly formats gene sets and generates the $X$ matrix
We can source any gene set from `WebGestaltR::listGeneSet()`

```{r geneset.setup, message=FALSE, results='hide'}
gs_list <- WebGestaltR::listGeneSet()
gobp <- loadGeneSetX('geneontology_Biological_Process', min.size=50)  # just huge number of gene sets
gobp_nr <- loadGeneSetX('geneontology_Biological_Process_noRedundant', min.size=1)
gomf <- loadGeneSetX('geneontology_Molecular_Function', min.size=1)
kegg <- loadGeneSetX('pathway_KEGG', min.size=1)
reactome <- loadGeneSetX('pathway_Reactome', min.size=1)
wikipathway_cancer <- loadGeneSetX('pathway_Wikipathway_cancer', min.size=1)
wikipathway <- loadGeneSetX('pathway_Wikipathway', min.size=1)

genesets <- list(
  gobp=gobp,
  gobp_nr=gobp_nr,
  gomf=gomf,
  kegg=kegg,
  reactome=reactome,
  wikipathway_cancer=wikipathway_cancer,
  wikipathway=wikipathway
)
```

```{r data.setup}
load('data/pbmc-purified/deseq2-pbmc-purified.RData')

convert_labels <- function(y, from='SYMBOL', to='ENTREZID'){
  hs <- org.Hs.eg.db::org.Hs.eg.db
  gene_symbols <- names(y)
  symbol2entrez <- AnnotationDbi::select(hs, keys=gene_symbols, columns=c(to, from), keytype = from)
  symbol2entrez <- symbol2entrez[!duplicated(symbol2entrez[[from]]),]
  symbol2entrez <- symbol2entrez[!is.na(symbol2entrez[[to]]),]
  symbol2entrez <- symbol2entrez[!is.na(symbol2entrez[[from]]),]
  rownames(symbol2entrez) <- symbol2entrez[[from]]
  ysub <- y[names(y) %in% symbol2entrez[[from]]]
  names(ysub) <- symbol2entrez[names(ysub),][[to]]
  return(ysub)
}


par(mfrow=c(1,1))
deseq$`CD19+ B` %>% .$padj %>% hist(main='CD19+B p-values')
```


### Fitting and reporting helpers

```{r driver}
#' fit logistic susie, and hypergeometric test
logistic_susie_driver = function(db, celltype, thresh){
  gs <- genesets[[db]]
  data <- deseq[[celltype]]

  # set up binary y
  y <- data %>%
    as.data.frame %>%
    rownames_to_column('gene') %>%
    dplyr::select(gene, padj) %>%
    filter(!is.na(padj)) %>%
    mutate(y = as.integer(padj < thresh)) %>%
    select(gene, y) %>%
    tibble2namedlist %>%
    convert_labels('ENSEMBL')
  
  u <- process_input(gs$X, y)  # subset to common genes
  vb.fit <- logistic.susie(  # fit model
    u$X, u$y, L=10, init.intercept = 0, verbose=1, maxit=100)

  #' hypergeometric test
  ora <- tibble(
    geneSet = colnames(u$X),
    geneListSize = sum(u$y),
    geneSetSize = colSums(u$X),
    overlap = (u$y %*% u$X)[1,],
    nGenes = length(u$y),
    propInList = overlap / geneListSize,
    propInSet = overlap / geneSetSize,
    oddsRatio = (overlap / (geneListSize - overlap)) / (
      (geneSetSize - overlap) / (nGenes - geneSetSize + overlap)),
    pValueHypergeometric = phyper(
      overlap-1, geneListSize, nGenes, geneSetSize, lower.tail= FALSE),
    db = db,
    celltype = celltype,
    thresh = thresh
  ) %>% 
  left_join(gs$geneSet$geneSetDes)

  return(list(
    fit = vb.fit,
    ora = ora,
    db = db, celltype = celltype, thresh = thresh))
}

credible_set_summary = function(res){
  gs <- genesets[[res$db]]
  data <- deseq[[res$celltype]]

  # set up binary y
  y <- data %>%
    as.data.frame %>%
    rownames_to_column('gene') %>%
    dplyr::select(gene, padj) %>%
    filter(!is.na(padj)) %>%
    mutate(y = as.integer(padj < res$thresh)) %>%
    select(gene, y) %>%
    tibble2namedlist %>%
    convert_labels('ENSEMBL')
  
  u <- process_input(gs$X, y)  # subset to common genes

  #' report top 50 elements in cs
  credible.set.summary <- t(res$fit$alpha) %>%
    data.frame() %>%
    rownames_to_column(var='geneSet') %>%
    rename_with(~str_replace(., 'X', 'L')) %>%
    pivot_longer(starts_with('L'), names_to='component', values_to = 'alpha') %>%
    arrange(component, desc(alpha)) %>%
    dplyr::group_by(component) %>%
    filter(row_number() < 50) %>%
    mutate(cumalpha = c(0, head(cumsum(alpha), -1))) %>%
    mutate(in_cs = cumalpha < 0.95) %>%
    mutate(active_cs = component %in% names(res$fit$sets$cs)) %>%
    left_join(res$ora) %>%
    left_join(gs$geneSet$geneSetDes)

  #' map each gene set to the component with top alpha
  #' report pip
  gene.set.summary <- res$fit$pip %>% 
    as_tibble(rownames='geneSet') %>%
    rename(pip=value) %>%
    left_join(res$ora) %>%
    left_join(gs$geneSet$geneSetDes)

  return(credible.set.summary)
}

gene_set_summary = function(res){
  gs <- genesets[[res$db]]
  #' map each gene set to the component with top alpha
  #' report pip
  res$fit$pip %>% 
    as_tibble(rownames='geneSet') %>%
    rename(pip=value) %>%
    left_join(res$ora) %>%
    left_join(gs$geneSet$geneSetDes)
}
```


### Example usage

```{r run.example}
db = 'gobp'
celltype = 'CD19+ B'
thresh = 1e-4
res <- logistic_susie_driver(db, celltype, thresh)
credible_set_summary(res) %>% head()
gene_set_summary(res) %>% head()
```

## Fit PBMC data

For each celltype, we fit logistic SuSiE using multiple gene set sources at various threshold of `padj`.

```{r run.all, results='hide', message=FALSE}
celltypes <- names(deseq)
pthresh <- c(1e-4) # c(0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001)
db_name <- names(genesets)
crossed <- cross3(db_name, celltypes, pthresh)

pbmc_res <- xfun::cache_rds({
  res <- purrr::map(crossed, purrr::lift_dl(logistic_susie_driver))
  for (i in 1:length(res)){  # save some space
    res[[i]]$fit$dat <- NULL
  }
  res
  }
)

u <- map(pbmc_res, credible_set_summary)
pbmc.cs.summary <- do.call('rbind', u)
cs.summary <- pbmc.cs.summary

u <- map(pbmc_res, gene_set_summary)
pbmc.geneset.summary <- do.call('rbind', u)
geneset.summary <- pbmc.geneset.summary
```

### Summary functions

Just a few functions to help streamline looking at output

```{r report.result.functions}
library(kableExtra)
#' takes a tibble
#' organize by database and component
#' report credible set, descriptions, pips, and hypergeometric pvalue
#' in one row, with cs ordered by pip
db_component_kable = function(tbl){
  tbl %>%
  filter(active_set, thresh==1e-4) %>%
  group_by(db, celltype, top_component) %>%
  arrange(db, celltype, top_component, desc(pip)) %>%
  select(geneSet, description, pip, pValueHypergeometric) %>%
  chop(c(geneSet, description, pip, pValueHypergeometric)) %>%
  knitr::kable()
}

#' takes a tibble
#' organize by database and component
#' report credible set, descriptions, pips, and hypergeometric pvalue
#' in one row, with cs ordered by pip
db_component_kable = function(tbl, min_alpha=0, max_sets=10){
  tbl_filtered <-
    tbl %>%
    group_by(celltype, db, component) %>%
    arrange(celltype, db, component, desc(alpha)) %>%
    filter(alpha > min_alpha, row_number() <= max_sets)

  tbl_filtered %>%
    select(geneSet, description, alpha, pValueHypergeometric) %>%
    dplyr::mutate_if(is.numeric, funs(as.character(signif(., 3)))) %>%
    kbl() %>%
    column_spec(c(4, 5, 6), color=ifelse(tbl_filtered$in_cs, 'green', 'red')) %>%
    collapse_rows(columns = c(1, 2), valign = 'top') %>%
    kableExtra::kable_styling()
}
```
  

## Results

Here for each cell type and gene set database, we look at the top 10 gene sets per SuSiE component. Gene sets are colored green if they're in the credible set and red otherwise.

There tables are a lot to look at, so I'll have to come back and summarise results somehow.

General obseravtion: 
* Virtually ALL of these gene sets report as highly significant by hypergeometric test
* For "dense" gene set sources like GO-BP the top 10 gene sets in a component are often closely related, but outside of the credible set often have vanishingly small `alpha`. So although they are marginally enriched, logistic SuSiE thinks that other gene sets provide a much better explaination for the observed gene list. I think this is the type of result we want to see-- credible sets capture related gene sets and nominate one/a few of them
* Sometime we see a mix of topics within a component.

The tables are really long, so for each cell-type I summarize the components into "themes"


```{r all.tables, results="asis"}
library(htmltools)

gen.table = function(ct, g){
  pbmc.cs.summary %>%
        filter(celltype == ct, db == g, active_cs) %>%
        db_component_kable() %>%
        htmltools::HTML()
}
possibly.gen.table = possibly(gen.table, otherwise="nothing to report...")

for(ct in celltypes){
  cat("\n") 
  cat("##", ct, "\n") # Create second level headings with the names.
  
  for(g in names(genesets)){
    cat("###", g, "\n") # Create second level headings with the names.
    possibly.gen.table(ct, g) %>% print()
    cat("\n")
  }
}
```


## Designing visualizations

There are a lot of facets of the enrichment results we might want to communicate.

Its common to plot against the proportion of the genes in the list, but this obscures the sensitivity of the analysis to gene set size. Recreating a standard enrichment plot.

```{r vis.standard}
ct = celltypes[1]
gs = 'gobp'

cs.summary %>%
  filter(celltype == ct, db == gs, active_cs, row_number() <= 10) %>%
  mutate(geneSet=factor(geneSet, levels=geneSet[order((propInList))])) %>%
  arrange(component, desc(propInList)) %>%
  ggplot(aes(x=propInList, y=geneSet, size=geneSetSize, color=-log10(pValueHypergeometric))) +
  geom_point() + facet_wrap(vars(component), scale='free_y', ncol = 1)
```

The strongest marginal enticements come from the largest gene sets.
But SuSiE is able to prioritizing smaller gene sets. The right ones? Who knows.

```{r p.and.setsize}
cs.summary %>%
  ggplot(aes(x=-log10(pValueHypergeometric), y=geneSetSize)) +
  geom_point() + geom_smooth()
```

Here, for the gene sets assigned to SuSiE components, we plot the proportion of the gene set observed. The bubble size is given by the gene set size, and the color indicates `alpha`, the posterior probability that the gene set is selected by the component. 

I'm surprised to see gene sets with large alpha, but only modest proportion

```{r new.vis}

cs.summary %>%
  filter(celltype == ct, db == 'gobp', active_cs, row_number() <= 10) %>%
  mutate(geneSet=factor(geneSet, levels=geneSet[order((propInList))])) %>%
  arrange(component, desc(propInList)) %>%
  ggplot(aes(x=propInList, y=geneSet, color=alpha, size=geneSetSize)) +
  geom_point() + facet_wrap(vars(component), scale='free_y', ncol = 1)

cs.summary %>%
  filter(celltype == ct, db == 'gobp', active_cs, row_number() <= 10) %>%
  mutate(geneSet=factor(geneSet, levels=geneSet[order((propInList))])) %>%
  arrange(component, desc(propInList)) %>%
  ggplot(aes(x=propInList, y=geneSet, color=in_cs, size=geneSetSize)) +
  geom_point() + facet_wrap(vars(component), scale='free_y', ncol = 1)
```

## Credible set distributions

```{r}
cs.summary %>%
  group_by(celltype, db, component) %>%
  summarise(entropy = -sum(alpha * log(alpha)), n = n()) %>%
  ggplot(aes(x=entropy)) + geom_histogram() + labs(title='component entropy')

cs.summary %>%
  filter(active_cs, in_cs) %>%
  group_by(celltype, db, component) %>%
  summarise( n = n()) %>%
  ggplot(aes(x=n)) + geom_histogram() + labs(title='95% Credible set size')
```

```{r}
knitr::knit_exit()
```
