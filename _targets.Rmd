---
title: "Target Markdown"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

```{r}
library(targets)
tar_unscript()
```


```{targets globals, tar_globals=TRUE}
library(tidyverse)
library(tidyr)
library(glue)
library(tarchetypes)
library(clustermq)
library(conflicted)

# Manage naming conflicts

conflict_prefer("select", "dplyr", "AnnotationDbi")
conflict_prefer("filter", "dplyr")
conflict_prefer("rename", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("desc", "dplyr")

# callr cant find these when used in 'tar_option_set'
# but these imports would be better placed there
# Both installed via bioconductor so maybe that's a hint
require(GSEABenchmarkeR, quietly = T)
require(EnrichmentBrowser, quietly = T)

source('code/load_gene_sets.R')
source('code/simulate_gene_lists.R')
source('code/score_simulations.R')
source('target_components/methods.R')

options(clustermq.scheduler = "multiprocess")
tar_option_set(workspace_on_error = TRUE)

tar_option_set(packages = c(
  "tidyverse", "WebGestaltR",
  "Matrix", "susieR", "glmnet",
  "mr.ash.alpha", "VEB.Boost", "fastglm"))
tar_option_set(memory='transient', garbage_collection = T, error='workspace')


get.test.sim.params <- function(){
  return(crossing(
    active.logit=c(-6, -5, -4, -3, -2),
    background.logit=c(-2, -1, 0, 1, 2),
    sim_function = c('simulate.constant.sim')))
}
test.sim.params <- get.test.sim.params()
test.sim.params <- test.sim.params %>% rowwise() %>%
  mutate(
    params = list(
      setNames(
        c_across(!sim_function),
        colnames(select(test.sim.params, !sim_function)))),
    X='X.gonr'
  )

get.methods <- function(){
  method_bank %>% dplyr::filter(
    method.name %in% c(
      'fet',
      'susie.10',
      'logistic.susie.veb.boost.10'
    )
  )
}
methods <- get.methods()

```

Near the top of the document, you may also wish to remove the `_targets_r` directory previously written by non-interactive runs of the report. Otherwise, your pipeline may contain superfluous targets.


## Get gene sets
```{targets load-genesets}
tar_target(X.gonr, load.webGestalt.X())
```


## Simulations

```{targets factories, tar_globals = TRUE}
## old
sim_factory_single <- function(name, FUN, params, batches=1, reps=1){
  # replicate simulation
  list(
    tar_rep_raw(
      name,
      expr(lift_dl(match.fun(!!FUN))(params)),
      batches = batches,
      reps = reps,
      iteration='group'
    ) %>%
    tar_hook_outer(
      matches(name),
      hook = as.tibble(.x)
    )
  )
}

## Simulation Factory
sim_factory <- function(prefix, X, params, batches=1, reps=1){
  X <- enexpr(X)
  target_name <- paste0(prefix, '.sim')
  tar_rep_raw(
    target_name,
    expr(
      !!params %>%
        rowwise() %>%
        mutate(sim = list(lift_dl(match.fun(sim_function))(c(list(X=!!X), params))))),
    batches = batches,
    reps = reps,
    iteration='group') %>%
    tar_hook_outer(
      matches(target_name),
      hook = as.tibble(.x)
    )
}

list2namedlist <- function(l1, l2){
  names(l1) <- l2
  return(l1)
}

## Model fitting factory
fit_factory <- function(prefix, X, target_sim, method_spec) {
  ts <- enexpr(target_sim)
  XX <- enexpr(X)
  f <- expr(
    lift(match.fun(method_function))(sym(X), sim$Y[,1])
  )
  target_name <- paste0(prefix, '.fit')
  tar_map(
    values = method_spec, names = method.name,
    tar_target_raw(
      target_name,
      expr(
        !!ts %>% rowwise() %>% mutate(
          pf = list(force(purrr::partial(match.fun(method_function), X=!!XX, y=sim$Y[,1]))),
          fit = list(lift_dl(pf)(list2namedlist(method_args, ma_names)))
        ) %>% select(!pf)
      ),
      pattern = expr(map(!!ts))
    )
  )
}

## Model scoring factory
generate_score_target <- function(prefix, method.name, prediction_col){
  target_score_name <- paste0(prefix, '.score_', method.name)
  target_score_name <- expr(!!target_score_name)
  
  target_fit <-sym(paste0(prefix, '.fit_', method.name))
  target_fit <- expr(!!target_fit)
  
  prediction_col <- expr(!!prediction_col)
  method_name <- expr(!!method.name)
  
  target_pattern = expr(map(!!target_fit))
  
  score_expression <- expr(
    tar_target_raw(
      !!target_score_name,
      expr(!!target_fit %>% rowwise() %>% mutate(
        scores = list(get.score(fit[[!!prediction_col]][[1]], sim$active)),
        score.cs = if(grepl('susie', !!method_name)) {list(score.credible.set(fit, sim$active))} else {list(NULL)}
      )), pattern=expr(!!target_pattern)
    )
  )
  return(score_expression)
}
score_factory <- function(prefix, methods){
  return(lapply(tar_eval(generate_score_target(prefix, method.name, prediction_col), values = methods), eval))
}
```

## L1 Sim

Simulate a single active gene set from `GO-BP no redundnant`

```{targets l1.sim}
## set simulation parameters
get.l1.sim.params <- function(){
  params <- crossing(
    background.logit=c(-6, -5, -4, -3, -2),
    active.logit=c(-2, -1, 0, 1, 2),
    sim_function = c('simulate.constant.sim'),
    X='X.gonr')

  params <- params %>% mutate(
    param_names = list((params %>% select(!c(X, sim_function)) %>% colnames()))
  ) %>% rowwise() %>% mutate(
    params = list(setNames(c_across(!c(X, sim_function, param_names)), param_names))
  )
}
l1.gonr.sim.params <- get.l1.sim.params()

## pick methods to include in this sim
l1.gonr.methods <- method_bank %>% dplyr::filter(
  method.name %in% c(
    'fet',
    'susie.10',
    'logistic.susie.veb.boost.10'
  )) %>%
  mutate(ma_names = map(method_args, names))


list(
  sim_factory('l1.gonr', X.gonr, l1.gonr.sim.params, tar_toggle(1, 5), tar_toggle(1, 5)),
  fit_factory('l1.gonr', X.gonr, l1.gonr.sim, l1.gonr.methods),
  score_factory('l1.gonr', l1.gonr.methods)
)
```

## Pipeline

If you ran all the `{targets}` chunks in non-interactive mode, then your R scripts are set up to run the pipeline.

```{r}
tar_make()
```

The `targets` dependency graph helps your readers understand the steps of your pipeline at a high level.

```{r}
tar_visnetwork()
```

At this point, you can go back and run `{targets}` chunks in interactive mode without interfering with the code or data of the non-interactive pipeline.
