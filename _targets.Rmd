---
title: "Target Markdown"
output:
  html_document: default
  pdf_document: default
---
## Setup 

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

```{r}
library(targets)
tar_unscript()
options(clustermq.scheduler = "multiprocess")
```

```{targets global-imports, tar_globals=TRUE}
library(targets)
library(tidyverse)
library(glue)
library(tarchetypes)
library(clustermq)
library(conflicted)
library(gseareg)

# Manage naming conflicts
conflict_prefer("select", "dplyr", "AnnotationDbi")
conflict_prefer("filter", "dplyr")
conflict_prefer("rename", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("desc", "dplyr")

# callr cant find these when used in 'tar_option_set'
# but these imports would be better placed there
# Both installed via bioconductor so maybe that's a hint
require(GSEABenchmarkeR, quietly = T)
require(EnrichmentBrowser, quietly = T)

source('code/target_factories.R')
source('code/target_simulate_gene_lists.R')
source('code/target_score_simulation.R')

options(clustermq.scheduler = "multiprocess")
tar_option_set(workspace_on_error = TRUE)

tar_option_set(packages = c(
  "tidyverse", "WebGestaltR",
  "Matrix", "susieR", "glmnet",
  "mr.ash.alpha", "VEB.Boost", "fastglm"))
tar_option_set(memory='transient', garbage_collection = T, error='workspace')

REP <- tar_toggle(1, 2)
BATCH <- tar_toggle(1, 10)
```

## Methods

To add a method add a row to `method_lookup` and `score_lookup`
`method_function` should take arguments `X` and `y`
`score_function` should take arguments `fit` and `sim`

```{targets method_bank, tar_globals=TRUE}
fit_logistic_susie_l1 = function(X, y){
  gseareg::fit_logistic_susie(X, y, L=1, maxit=100)
}
fit_linear_susie_l1 = function(X, y){
  susieR::susie(X, y, L=1)
}
fit_logistic_susie_l10 = function(X, y){
  gseareg::fit_logistic_susie(X, y, L=10, maxit=100)
}
fit_linear_susie_l10 = function(X, y){
  susieR::susie(X, y, L=10)
}
fit_linear_lasso = function(X, y){
  glmnet::cv.glmnet(X, y, family='gaussian', alpha=1)
}
fit_logistic_lasso = function(X, y){
  glmnet::cv.glmnet(X, y, family='binomial', alpha=1)
}

method_lookup <- tribble(
  ~method_name, ~method_function, ~method_args,
  'ora', gseareg::fit_ora, list(),
  'logistic_susie.l1', fit_logistic_susie_l1, list(L=1),
  'linear_susie.l1', fit_linear_susie_l1, list(L=1),
  'logistic_susie.l10', fit_logistic_susie_l10, list(L=1),
  'linear_susie.l10', fit_linear_susie_l10, list(L=1),
  'linear_lasso', fit_linear_lasso, list(),
  'logistic_lasso', fit_logistic_lasso, list()
)

score_ora = function(fit, sim){return(list(a=c(1, 2, 3)))}
score_susie = function(fit, sim){return(list(a=c(1, 2, 3)))}

score_lookup <- tribble(
  ~method_name, ~score_function,
  'ora', score_phyper,
  'logistic_susie.l1', score_pip,
  'linear_susie.l1', score_pip,
  'logistic_susie.l10', score_pip,
  'linear_susie.l10', score_pip,
  'linear_lasso', score_cvglmnet,
  'logistic_lasso', score_cvglmnet
)
```

## Targets

### Get gene sets
```{targets load-genesets}
list(
  tar_target(genesets, gseareg::load_gene_sets()),
  tar_target(X.gonr, genesets$gobp$X)
)
```

## L1 Simulation

Simulate a single active gene set from `GO-BP no redundnant`

```{targets l1.sim}
## set simulation parameters
get.l1.sim.params <- function(){
  params <- crossing(
    #background.logit=c(-8, -6, -4, -2),
    #active.logit=c(-4, -2, 0, 2, 4),
    background.logit = c(-4),
    active.logit = c(0),
    sim_function = c('simulate.constant.sim'),
    X='X.gonr')

  simulate.constant.sim
  params <- params %>% mutate(
    param_names = list((params %>% select(!c(X, sim_function)) %>% colnames()))
  ) %>% rowwise() %>% mutate(
    params = list(setNames(c_across(!c(X, sim_function, param_names)), param_names))
  )
}

# target metadata/specification
l1.gonr.sim.params <- get.l1.sim.params()
l1.gonr.methods <- method_lookup
l1.gonr.score_lookup <- l1.gonr.methods %>%
  left_join(score_lookup)

# execute pipeline
list(
  make_sim_spec('l1.gonr', l1.gonr.sim.params, BATCH, REP),
  sim_factory('l1.gonr', X.gonr, l1.gonr.spec),
  fit_factory('l1.gonr', X.gonr, l1.gonr.sim, l1.gonr.methods),
  score_factory('l1.gonr', l1.gonr.score_lookup)
)
```

```{r}
tar_visnetwork()
```
```{r}
knitr::knit_exit()
```



```{targets l1.sim.old}
## pick methods to include in this sim
l1.gonr.methods <- method_bank %>% dplyr::filter(
  method.name %in% c(
    'fet',
    'susie.10',
    'logistic.susie.10',
    'logistic.susie.veb.boost.10',
    'lasso.gaussian',
    'elastic.net.gaussian',
    'lasso.binomial',
    'elastic.net.binomial',
    'mr.ash.lasso'
  )) %>%
  mutate(ma_names = map(method_args, names))

list(
  make_sim_spec('l1.gonr', l1.gonr.sim.params, BATCH, REP),
  sim_factory('l1.gonr', X.gonr, l1.gonr.spec),
  fit_factory('l1.gonr', X.gonr, l1.gonr.sim, l1.gonr.methods),
  score_factory('l1.gonr', l1.gonr.methods)
)
```



```{targets constant.sim}
## set simulation parameters
get.constant.sim.params <- function(){
  params <- crossing(
    background.logit=c(-8, -6, -4, -2),
    active.logit=c(-2, -1, 0, 1, 2),
    sim_function = c('simulate.constant.sim'),
    L = c(5, 10, 20),
    X='X.gonr')
  params <- params %>% mutate(
    param_names = list((params %>% select(!c(X, sim_function)) %>% colnames()))
  ) %>% rowwise() %>% mutate(
    params = list(setNames(c_across(!c(X, sim_function, param_names)), param_names))
  )
}
constant.gonr.sim.params <- get.constant.sim.params()

## pick methods to include in this sim
constant.gonr.methods <- method_bank %>% dplyr::filter(
  method.name %in% c(
    'fet',
    'susie.10',
    'susie.20',
    'logistic.susie.10',
    'logistic.susie.veb.boost.10',
    'logistic.susie.veb.boost.20',
    'lasso.gaussian',
    'elastic.net.gaussian',
    'lasso.binomial',
    'elastic.net.binomial'
  )) %>%
  mutate(ma_names = map(method_args, names))

list(
  make_sim_spec('constant.gonr', constant.gonr.sim.params, BATCH, REP),
  sim_factory('constant.gonr', X.gonr, constant.gonr.spec),
  fit_factory('constant.gonr', X.gonr, constant.gonr.sim, constant.gonr.methods),
  #score_factory('constant.gonr', constant.gonr.methods)
)
```

## Constant Additive Sim

Fixed background rate, fixed beta across $L$ active gene sets.
The point of this simulation is to explore the relative performance of
SuSiE and logistic SuSiE across a range of enrichment/background levels

```{targets constant.additive.sim}
## set simulation parameters
get.constant.additive.sim.params <- function(){
  params <- crossing(
    background.logit=seq(-10, -2, 2),
    active.logit=c(0:10),
    sim_function = 'simulate.constant.additive.sim',
    L = c(5, 10, 20),
    X='X.gonr') %>%
    filter(((background.logit + active.logit) >= 0)) %>%
    filter((background.logit + active.logit <= 5))

  params <- params %>% mutate(
    param_names = list((params %>% select(!c(X, sim_function)) %>% colnames()))
  ) %>% rowwise() %>% mutate(
    params = list(setNames(c_across(!c(X, sim_function, param_names)), param_names))
  )
}
constant.additive.gonr.sim.params <- get.constant.additive.sim.params()

## pick methods to include in this sim
constant.additive.gonr.methods <- method_bank %>% dplyr::filter(
  method.name %in% c(
    'fet',
    'susie.10',
    'susie.20',
    'logistic.susie.10',
    'logistic.susie.veb.boost.10',
    'logistic.susie.veb.boost.20',
    'lasso.gaussian',
    'elastic.net.gaussian',
    'lasso.binomial',
    'elastic.net.binomial',
    'mr.ash.alpha'
  )) %>%
  mutate(ma_names = map(method_args, names))

list(
  make_sim_spec('constant.additive.gonr', constant.additive.gonr.sim.params, BATCH, REP),
  sim_factory('constant.additive.gonr', X.gonr, constant.additive.gonr.spec),
  fit_factory('constant.additive.gonr', X.gonr, constant.additive.gonr.sim, constant.additive.gonr.methods),
  score_factory('constant.additive.gonr', constant.additive.gonr.methods)
)
```


## Summarise

```{r}

```

## Pipeline

If you ran all the `{targets}` chunks in non-interactive mode, then your R scripts are set up to run the pipeline.

```{r}
#tar_make()
```

The `targets` dependency graph helps your readers understand the steps of your pipeline at a high level.

```{r}
tar_visnetwork()
```

At this point, you can go back and run `{targets}` chunks in interactive mode without interfering with the code or data of the non-interactive pipeline.
